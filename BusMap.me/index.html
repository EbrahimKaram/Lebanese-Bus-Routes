<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Lebanon Bus Routes — Viewer & Editor</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #topbar {
            position: absolute;
            z-index: 1000;
            left: 8px;
            bottom: 8px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
        }

        #props {
            position: absolute;
            right: 8px;
            top: 8px;
            z-index: 1000;
            width: 300px;
            max-height: 80vh;
            overflow: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
        }

        label {
            display: block;
            margin-top: 6px;
            font-size: 13px;
        }

        input,
        select,
        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 6px;
            margin-top: 4px;
        }

        button {
            margin-top: 8px;
            padding: 8px 10px;
            cursor: pointer;
        }

        .small {
            font-size: 12px;
            color: #333;
        }

        #layersList::-webkit-scrollbar {
            width: 8px;
        }

        #layersList::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        #layersList::-webkit-scrollbar-track {
            background: transparent;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <div id="topbar">
        <div style="display:flex; gap:6px; align-items:center;">
            <input id="fileInput" type="file" accept=".json,.geojson" />
            <button id="downloadBtn">Download edited GeoJSON</button>
            <button id="zoomAll">Zoom to routes</button>
        </div>
    </div>

    <div id="props">
        <div>
            <strong style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;"
                id="layersHeader">
                Layers
                <button id="toggleLayersBtn" style="font-size:14px; padding:2px 6px;">−</button>
            </strong>
            <input type="search" id="layersSearch" placeholder="Search layers..."
                style="width:100%; margin-top:4px; padding:4px; box-sizing:border-box;" />
            <div id="layersList"
                style="max-height: 250px; overflow-y: auto; margin-top:4px; border: 1px solid #ccc; border-radius: 4px; padding: 4px;">
                <!-- Layer entries here -->
            </div>
        </div>
        <hr />
        <strong>Selected feature properties</strong>
        <form id="propsForm" onsubmit="return false;">
            <!-- Dynamic properties fields inserted here -->
            <div id="propsFields"></div>
            <button type="button" id="saveProps">Save properties</button>
            <button type="button" id="clearSelection">Clear selection</button>
            <button type="button" id="editPath">Edit path</button>
            <button type="button" id="savePath">Save path</button>
        </form>

    </div>

    <script>
        (async function () {
            const map = L.map('map').setView([33.9, 35.5], 8);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18, attribution: '© OpenStreetMap'
            }).addTo(map);

            const editableFG = new L.FeatureGroup().addTo(map);

            // Only allow drawing of new polylines
            const drawControl = new L.Control.Draw({
                edit: false,
                draw: {
                    polygon: false,
                    rectangle: false,
                    circle: false,
                    marker: false,
                    circlemarker: false,
                    polyline: { shapeOptions: { color: '#3388ff' } }
                }
            });
            map.addControl(drawControl);

            let geojsonData = null;
            let selectedLayer = null;
            let selectedFeature = null;
            let layerToFeatureId = new Map();
            let currentEditor = null;

            function styleForFeature(props) {
                let col = props && (props.color_path || props.color || '#3388ff');
                let weight = (props && parseInt(props.line_thik)) || 4;
                return { color: col, weight: weight, opacity: 0.85 };
            }

            // DYNAMIC properties form population
            function populatePropsForm(properties) {
                const container = document.getElementById('propsFields');
                container.innerHTML = ''; // Clear old inputs

                for (const key in properties) {
                    if (!properties.hasOwnProperty(key)) continue;
                    const value = properties[key];

                    const label = document.createElement('label');
                    label.textContent = key;
                    label.style.marginTop = '6px';

                    let input;
                    if (typeof value === 'string' && value.length > 40) {
                        // long text - use textarea
                        input = document.createElement('textarea');
                        input.rows = 3;
                        input.style.width = '100%';
                        input.value = value;
                    } else if (typeof value === 'number' || (!isNaN(value) && value !== null && value !== '')) {
                        // treat as number if numeric string or number
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = value;
                        input.style.width = '100%';
                    } else {
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = value;
                        input.style.width = '100%';
                    }

                    input.id = `prop_${key}`;
                    input.dataset.propKey = key;

                    label.appendChild(input);
                    container.appendChild(label);
                }
            }

            function setGeoJSON(j) {
                geojsonData = j;
                editableFG.clearLayers();
                layerToFeatureId.clear();
                if (!j || !j.features) return;

                j.features.forEach((feat, idx) => {
                    if (feat.geometry && feat.geometry.type === "LineString") {
                        const coords = feat.geometry.coordinates.map(c => [c[1], c[0]]);
                        const layer = L.polyline(coords, styleForFeature(feat.properties || {}));
                        editableFG.addLayer(layer);
                        layerToFeatureId.set(layer, idx);
                        layer.on('click', () => selectLayer(layer, idx));
                    }
                });

                rebuildLayersList();
                const bounds = editableFG.getBounds();
                if (bounds.isValid()) map.fitBounds(bounds, { padding: [20, 20] });
            }

            function rebuildLayersList() {
                const dom = document.getElementById('layersList');
                dom.innerHTML = '';
                if (!geojsonData) return;
                geojsonData.features.forEach((f, i) => {
                    const el = document.createElement('div');
                    el.style.padding = '6px 4px';
                    el.style.borderBottom = '1px solid #eee';
                    el.style.cursor = 'pointer';
                    el.innerHTML = `<strong>${(f.properties && f.properties.busname) || ('feature ' + i)}</strong>
                <div class="small">id: ${(f.properties && f.properties.id) || ''}</div>`;
                    el.onclick = () => {
                        for (const [layer, idx] of layerToFeatureId.entries()) {
                            if (idx === i) {
                                map.fitBounds(layer.getBounds ? layer.getBounds() : L.latLngBounds(layer.getLatLngs()));
                                selectLayer(layer, idx);
                                break;
                            }
                        }
                    };
                    dom.appendChild(el);
                });
            }

            function selectLayer(layer, featureIndex) {
                if (selectedLayer) {
                    selectedLayer.setStyle && selectedLayer.setStyle({ dashArray: null });
                }
                selectedLayer = layer;
                selectedFeature = geojsonData && geojsonData.features[featureIndex];
                if (selectedLayer.setStyle) selectedLayer.setStyle({ dashArray: '4 6' });
                if (selectedFeature && selectedFeature.properties) {
                    populatePropsForm(selectedFeature.properties);
                } else {
                    document.getElementById('propsFields').innerHTML = '';
                }
            }

            document.getElementById('saveProps').addEventListener('click', () => {
                if (!selectedFeature) { alert('Select a route first'); return; }
                const container = document.getElementById('propsFields');
                const inputs = container.querySelectorAll('input, textarea');
                const props = {};

                inputs.forEach(input => {
                    const key = input.dataset.propKey;
                    let val = input.value;

                    // Convert number inputs if possible
                    if (input.type === 'number') {
                        val = val === '' ? null : Number(val);
                    }

                    props[key] = val;
                });

                selectedFeature.properties = props;

                // Update style if color_path or line_thik changed
                if (selectedLayer && selectedFeature.properties) {
                    selectedLayer.setStyle && selectedLayer.setStyle(styleForFeature(selectedFeature.properties));
                }

                rebuildLayersList();
                alert('Properties saved (in memory). Use "Download edited GeoJSON" to save to disk.');
            });

            document.getElementById('clearSelection').addEventListener('click', () => {
                if (selectedLayer && selectedLayer.setStyle) selectedLayer.setStyle({ dashArray: null });
                selectedLayer = null; selectedFeature = null;
                document.getElementById('propsFields').innerHTML = '';
            });

            // Edit only selected path
            document.getElementById('editPath').addEventListener('click', () => {
                if (!selectedLayer) {
                    alert('Select a route first');
                    return;
                }
                if (currentEditor) {
                    alert('Already editing a path');
                    return;
                }
                currentEditor = new L.Edit.Poly(selectedLayer, { edit: true });
                currentEditor.enable();
            });

            document.getElementById('savePath').addEventListener('click', () => {
                if (!selectedLayer || !currentEditor) return;
                currentEditor.disable();
                currentEditor = null;
                const idx = layerToFeatureId.get(selectedLayer);
                if (typeof idx === 'number') {
                    geojsonData.features[idx].geometry = selectedLayer.toGeoJSON().geometry;
                }
                alert('Path saved');
            });

            // Handle new polyline creation
            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                editableFG.addLayer(layer);
                const gj = layer.toGeoJSON();
                gj.properties = gj.properties || {};
                gj.properties.id = gj.properties.id || ('new-' + Date.now());
                geojsonData = geojsonData || { type: 'FeatureCollection', features: [] };
                geojsonData.features.push(gj);
                const newIndex = geojsonData.features.length - 1;
                layerToFeatureId.set(layer, newIndex);
                layer.on('click', () => selectLayer(layer, newIndex));
                rebuildLayersList();
            });

            document.getElementById('downloadBtn').addEventListener('click', () => {
                if (!geojsonData) { alert('Nothing to download'); return; }
                geojsonData.features = geojsonData.features.filter(f => f !== null && f !== undefined);
                const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { type: 'application/json' });
                const filename = 'BusRoutes_edited.geojson';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = filename; document.body.appendChild(a);
                a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 5000);
            });

            document.getElementById('zoomAll').addEventListener('click', () => {
                const b = editableFG.getBounds();
                if (b.isValid()) map.fitBounds(b, { padding: [20, 20] });
                else alert('No features on the map yet.');
            });

            document.getElementById('fileInput').addEventListener('change', function (ev) {
                const f = ev.target.files[0];
                if (!f) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const j = JSON.parse(e.target.result);
                        setGeoJSON(j);
                    } catch (err) { alert('Invalid JSON file'); }
                };
                reader.readAsText(f);
            });

            try {
                await (async function loadGeoJSONFromURL(url = 'BusRoutes.json') {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error('fetch failed');
                    const j = await res.json();
                    setGeoJSON(j);
                })();
            } catch (e) {
                console.warn('Auto fetch failed, please use file input (CORS/file://).', e);
            }


            const layersList = document.getElementById('layersList');
            const layersSearch = document.getElementById('layersSearch');
            const toggleLayersBtn = document.getElementById('toggleLayersBtn');
            const layersHeader = document.getElementById('layersHeader');

            function rebuildLayersList(filteredIndices = null) {
                layersList.innerHTML = '';
                if (!geojsonData) return;
                geojsonData.features.forEach((f, i) => {
                    if (filteredIndices && !filteredIndices.includes(i)) return;
                    const el = document.createElement('div');
                    el.style.padding = '6px 4px';
                    el.style.borderBottom = '1px solid #eee';
                    el.style.cursor = 'pointer';
                    el.innerHTML = `<strong>${(f.properties && f.properties.busname) || ('feature ' + i)}</strong>
            <div class="small">id: ${(f.properties && f.properties.id) || ''}</div>`;
                    el.onclick = () => {
                        for (const [layer, idx] of layerToFeatureId.entries()) {
                            if (idx === i) {
                                map.fitBounds(layer.getBounds ? layer.getBounds() : L.latLngBounds(layer.getLatLngs()));
                                selectLayer(layer, idx);
                                break;
                            }
                        }
                    };
                    layersList.appendChild(el);
                });
            }

            layersSearch.addEventListener('input', () => {
                const query = layersSearch.value.trim().toLowerCase();
                if (!geojsonData) return;
                if (!query) {
                    rebuildLayersList();
                    return;
                }
                const filtered = geojsonData.features
                    .map((f, i) => ({ f, i }))
                    .filter(({ f }) => {
                        const bname = (f.properties && f.properties.busname || '').toLowerCase();
                        const id = (f.properties && ('' + f.properties.id) || '').toLowerCase();
                        return bname.includes(query) || id.includes(query);
                    })
                    .map(({ i }) => i);
                rebuildLayersList(filtered);
            });

            // Collapse / expand layers list
            let layersCollapsed = false;
            toggleLayersBtn.addEventListener('click', () => {
                layersCollapsed = !layersCollapsed;
                if (layersCollapsed) {
                    layersList.style.display = 'none';
                    layersSearch.style.display = 'none';
                    toggleLayersBtn.textContent = '+';
                } else {
                    layersList.style.display = 'block';
                    layersSearch.style.display = 'block';
                    toggleLayersBtn.textContent = '−';
                }
            });
        })();
    </script>
</body>

</html>